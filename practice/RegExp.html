<!DOCTYPE html>
<html>

<body>
  <script>
    'use strict';
    let re = /[0-2][0-9][:/-][0-5][0-9]/g; // выборка времени из строки
    console.log( "Завтрак в 33:59. Обед - в 09-57".match(re) ); 
    
    let re2 = /\d+\.\d+/g; // выборка десятичной дроби
    console.log('0 1 123.345003 7890.3'.match(re2));
    
    let re3 = /<[a-z][a-z0-9]*>/g; // найти открывающий тег без атрибутов. Например: <span>, <p>
    console.log('<div><p><span> Any text. </span></p><h1>Hi</h1></div>'.match(re3));
  
    let re4 = /<\/?[a-z][a-z0-9]*>/gi; // найти открывающий или закрывающий HTML-тег без атрибутов.
    console.log('<span>lorem</span><p>>>>><<<</P>'.match(re4));
    
    let re5 = /[\.!\?]{3,}/g; // найти многоточие три или более точек подряд, c учётом восклицательных и вопросительных знаков. 
    console.log("Привет!... Как дела?..... Норм... Ok.".match(re5));
    
    let re6 = /#[0-9a-f]{6}\b/gi; // регулярное выражение для поиска HTML-цвета в формате #123adc
    // \b здесь требует, чтобы в конце стоял не цифро-буквенный символ иначе шаблон не применится. 
    // т.е. если после шестого символа будет стоять цифра или буква, то такая строка не пройдет проверку
    // что нам и нужно. Ведь нам нужны только шесть символов. 
    
    let color = "color:#121212; background-color:#AA00ef bad-colors:f#fddee #fd2"
    console.log("re6", color.match(re6));
    
    // задача написать регулярное выражение, которое ищет HTML-цвета #abc или #abcdef. 
    let re6__2 = /#[a-f0-9]{3}([a-f0-9]{3})?\b/gi; // первый варинат
    let re6__2__2 = /#([a-f0-9]{3}){1,2}\b/gi; // второй вариант https://learn.javascript.ru/regexp-groups#tasks
    let color2 = "color: #3f3; background-color: #AA00ef; and: #abcd";
    console.log("re6__2", color2.match(re6__2));
    console.log("re6__2__2", color2.match(re6__2__2));
    
    let re7 = /\s\d+(\.\d+)?/g; //найти все положительные числа, в том числе и с десятичной точкой.
    let str7 = "1.5 0 12 -10 25 -0.004 123.4.";
    console.log(str7.match(re7));
    
    let re7__2 = /\-?\d+(\.\d+)?/g; //найти все положительные и отричательные числа, в том числе и с десятичной точкой.
    let str7__2 = "1.5 0 12 -10 2 25 -0.004 123.4 -10.004.";
    console.log(str7__2.match(re7__2)); 
    
    let re8 = /"[^"]+"/g; //найти все слова взятые в ковычки используя жадный поиск
    let str8 = 'Тишина. И в тишине слышны призывы "Вперёд!" и "Действуй!". А за окном -20'
    console.log(str8.match(re8));
    
    let re8__1 = /".+?"/g; // найти все слова взятые в ковычки используя ленивый поиск
    console.log(str8.match(re8__1));
    
    let re9 = /<!--[^>]*-->/g; // найти все html комментарии в тексте
    let str9 = '.. <!-- Мой -- комментарий \n тест --> <span>Lorem<!</span>  <!----> .. <br>';
    console.log("re9", str9.match(re9));
    
    let re9Second = /<!--[\s\S]*?-->/g; // второй способ найти все html комменты, используя ленивый поиск https://learn.javascript.ru/regexp-greedy-and-lazy#tasks
    console.log("re9Second", str9.match(re9Second))
    
    let re10 = /<[^>]+>/g; // регулярное выражение для поиска всех (открывающихся и закрывающихся) HTML-тегов вместе с атрибутами внутри этих тегов.
    // В этой задаче можно считать, что тег начинается с <, заканчивается > и может содержать внутри любые символы, 
    // кроме < и >. Но хотя бы один символ внутри тега должен быть: <> – не тег.
    let str10 = '<> <a href="/">Lorem</a> <input type="radio" checked> <b> <!--Comment-->';
    console.log("str10", str10.match(re10));
    
    /* Задача. Разобрать выражение.
    
    Арифметическое выражение состоит из двух чисел и операции между ними, например:
    
    1 + 2
    1.2 * 3.4
    -3 / -6
    -2 - 2
    Список операций: "+", "-", "*" и "/".
    
    Также могут присутствовать пробелы вокруг оператора и чисел.
    
    Напишите функцию, которая будет получать выражение и возвращать массив из трёх аргументов:
    
    Первое число.
    Оператор.
    Второе число.
    
    */
    
    function parseArithmeticalExpression(expr) {
      let reg = /(-?\d+(?:\.\d+)?)\s*([-+*\/])\s*(-?\d+(?:\.\d+)?)/;
      let result = expr.match(reg);
      if (!result) return;
      result.shift();
      return(result);
    }
    
    console.log("parseArithmeticalExpression: ", parseArithmeticalExpression("1 + 2"));
    console.log("parseArithmeticalExpression: ", parseArithmeticalExpression("1.2 * 3.4"));
    console.log("parseArithmeticalExpression: ", parseArithmeticalExpression("-3 / -6"));
    console.log("parseArithmeticalExpression: ", parseArithmeticalExpression("-2 - 2"));
    
  
  // Создайте регулярное выражение для поиска BB-тегов и их содержимого.  
  let reg11 = /\[\/?(\w+).*\1\]/g;
  let str11 = "..[url][b]http://ya.ru[/b][/url]..";
  console.log( "reg11", str11.match(reg11) ); // [url][b]http://ya.ru[/b][/url]
  // см. решение автора https://learn.javascript.ru/regexp-backreferences#tasks
    
  let reg12 = /java(script)?|php|c\+\+|\bc\b/gi; // найти все названия языков программирования
  let str12 = 'Java JavaScript PHP C++ C etc.';
  console.log("reg12", str12.match(reg12));

  let reg13 = /"(\\.|[^"\\])*"/g; // найти все слова в кавычках
  let str13 = ' .. "test me" .. "Скажи \\"Привет\\"!" .. "\\r\\n\\\\" .. ';
  console.log("reg13", str13.match(reg13));
  /*
  - Сначала ищем кавычку "
  - Затем, если далее слэш \\ (удвоение слэша – техническое, для вставки в регэксп, на самом деле там один слэш), то после него также подойдёт любой символ (точка).
  - Если не слэш, то берём любой символ, кроме кавычек (которые будут означать конец строки) и слэша (чтобы предотвратить одинокие слэши, сам по себе единственный слэш не нужен, он должен экранировать какой-то символ) [^"\\]
  - …И так жадно, до закрывающей кавычки.
  */

  let reg14 = /<style(>|\s.*>)/g;
  // Напишите регулярное выражение, которое будет искать в тексте тег <style>. Подходят как обычный тег <style>, так и вариант с атрибутами <style type="...">.
  //Но регулярное выражение не должно находить <styler>!
  let str14 = "<style> <styler> <style test>";
  console.log("str14", str14.match(reg14));



  let reg15 = /^([0-9a-f]{2}:){5}[0-9a-f]{2}$/i; // регулярное выражение, которое по строке проверяет, является ли она корректным MAC-адресом.
  // ^ означает совпадение с начала строки
  // $ означает конец строки
  console.log( "reg15", reg15.test('01:32:54:67:89:AB') ); // true
  console.log( "reg15", reg15.test('0132546789AB') ); // false (нет двоеточий)
  console.log( "reg15", reg15.test('01:32:54:67:89') ); // false (5 чисел, а не 6)
  console.log( "reg15", reg15.test('01:32:54:67:89:ZZ') ) // false (ZZ в конце)
  console.log( "reg15", reg15.test('01:32:54:67:89:AB:89') ) // false (больше 6 чисел)

  
  </script>
</body>
</html>